======The call Function======
“call”函数是唯一一个可以创建定制化参数函数的引用函数。使用这个函数可以实现对用户自己定义函数引用。我们可以将一个变量定义为一个复杂的表达式，用“call”函数根据不同的参数对它进行展开来获得不同的结果。

函数语法：
<code make>
$(call VARIABLE,PARAM,PARAM,...)
</code>
 

函数功能：在执行时，将它的参数“PARAM”依次赋值给临时变量“$(1)”、“$(2)”（这些临时变量定义在“VARIABLE”的值中，参考下边的例子）…… call函数对参数的数目没有限制，也可以没有参数值，没有参数值的“call”没有任何实际存在的意义。执行时变量“VARIABLE”被展开为在函数上下文有效的临时变量，变量定义中的“$(1)”作为第一个参数，并将函数参数值中的第一个参数赋值给它；变量中的“$(2)”一样被赋值为函数的第二个参数值；依此类推（变量$(0)代表变量“VARIABLE”本身）。之后对变量“VARIABLE” 表达式的计算值。

返回值：参数值“PARAM”依次替换“$(1)”、“$(2)”…… 之后变量“VARIABLE”定义的表达式的计算值。

函数说明：1. 函数中“VARIBLE”是一个变量名，而不是变量引用。因此，通常“call”函数中的“VARIABLE”中不包含“$”（当然，除非此变量名是一个计算的变量名）。2. 当变量“VARIBLE”是一个make内嵌的函数名时（如“if”、“foreach”、“strip”等），对“PARAM”参数的使用需要注意，因为不合适或者不正确的参数将会导致函数的返回值难以预料。3. 函数中多个“PARAM”之间使用逗号分割。4. 变量“VARIABLE”在定义时不能定义为直接展开式！只能定义为递归展开式。

函数示例：
首先，来看一个简单的例子。
示例1：
<code make>
reverse =  $(2) $(1)

foo = $(call reverse,a,b)
</code>
变量“foo”的值为“ba”。这里变量“reverse”中的参数定义顺序可以根据需要来调整，并不是需要按照“$(1)”、“$(2)”、“$(3)”…… 这样的顺序来定义。

看一个稍微复杂一些的例子。我们定义了一个宏“pathsearch”来在“PATH”路径中搜索第一个指定的程序。

示例2：
<code make>
pathsearch = $(firstword $(wildcard $(addsuffix /$(1),$(subst :, ,$(PATH)))))

LS := $(call pathsearch,ls)
</code>
变量“LS”的结果为“/bin/sh”。执行过程：函数“subst”将环境变量“PATH”转换为空格分割的搜索路径列表；“addsuffix”构造出可能的可执行程序“$(1)”（这里是“ls”）带路径的完整文件名（如：“/bin/$(1)”），之后使用函数“wildcard”匹配，最后“firstword”函数取第一个文件名。

函数“call”以可以套嵌使用。每一层“call”函数的调用都为它自己的局部变量“$(1)”等赋值，覆盖上一层函数为它所赋的值。
示例3：
<code make>
map = $(foreach a,$(2),$(call $(1),$(a)))

o = $(call map,origin,o map MAKE)
</code>

那么变量“o”的值就为“file file default”。我们这里使用了“origin”函数。我们分析函数的执行过程：首先，“o=$(call map,origin, o map MAKE)”这个函数调用使用了变量“map”所定义的表达式；使用内嵌函数名“origin”作为它的第一个参数值，使用Makefile中的变量“o map MAKE”作为他的第二个参数值。当使用“call”函数展开后等价于“$(foreach a,o map MAKE,$(origin $(a)))”。

注意：和其它函数一样，“call”函数会保留出现在其参数值列表中的空字符。因此在使用参数值时对空格处理要格外小心。如果参数中存在多余的空格，函数可能会返回一个莫名奇妙的值。为了安全，在变量作为“call”函数参数值之前，应去掉其值中的多余空格。
 --- //[[pest@qq.com|P.est]] 2013/11/25 11:40//